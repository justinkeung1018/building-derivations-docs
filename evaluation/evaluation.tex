\chapter{Evaluation}
\section{Correctness of algorithms}
The correctness of the parsing, matching, and verification algorithms are verified using unit tests. Some test cases are based on subsets of the pre-defined proof systems---natural deduction, Curry type assignment for the lambda calculus, and the sequent calculus system LK---while other test cases are based on variously modified rules from these systems and designed to catch edge cases. Some test cases based on the lambda calculus are taken from the course notes for the Type Systems module at Imperial \cite{van-bakel:2022}. Some test cases based on the system LK are taken from a set of online logic notes \cite{sequent}.

There is a high degree of confidence in the matching and verification algorithms, since they are based on custom data structures independent of the user input. To identify further edge cases in the parsing algorithm and determine how well the parsing algorithm adapts to a wide range of user inputs, the parsing algorithm is tested against extensions of the pre-defined systems and brand new proof systems.

\subsection{Lambda calculus with pairs}
\label{evaluation:lambda-pairs}
The syntaxes of $\lambda$-terms and Curry types are extended with the following constructors \cite{van-bakel:2022}:
\begin{align*}
    M, N &\Coloneqq \ldots \alt \langle M, N \rangle \alt \textsf{left}(M) \alt \textsf{right}(M) \\
    A, B &\Coloneqq \ldots \alt (A \times B)
\end{align*}
The three new constructors for $\lambda$-terms are accompanied with the following extensions to the type assignment rules:
\[
    (\textit{Pair}): \frac{\Gamma \vdash M: A \quad \Gamma \vdash N: B}{\Gamma \vdash \langle M, N \rangle: (A \times B)} \quad (\textsf{left}): \frac{\Gamma \vdash M: (A \times B)}{\Gamma \vdash \textsf{left}(M): A} \quad (\textsf{right}): \frac{\Gamma \vdash M: (A \times B)}{\Gamma \vdash \textsf{right}(M): B} 
\]
Although the user can type ``left'' and ``right'' for the two constructors, they will be rendered in math mode in \LaTeX{} as $left$ and $right$, which do not look the nicest. Prior to testing with the lambda calculus with pairs, the parsing algorithm can only handle \LaTeX{} commands that do not take any arguments, such as ``\textbackslash Gamma'' for $\Gamma$ and ``\textbackslash varphi'' for $\varphi$. The lambda calculus with pairs motivates extending the parsing algorithm to parse \LaTeX{} commands as literal strings. In this case, ``\textbackslash textsf{left}(M)'' should be rendered as $\textsf{left}(M)$ and parsed into \lstinline{Token}s as
\begin{center}
    \lstinline|[Terminal("\textsf{left}"), Terminal("("), NonTerminal(...), Terminal(")")]|
\end{center}
A correct derivation using all three newly added constructors and type assignment rules is shown in \Cref{fig:lambda-with-pairs}.
\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{evaluation/lambda-with-pairs.png}
    \caption{A correct derivation }
    \label{fig:lambda-with-pairs}
\end{figure}

\subsection{\lbm{}}
The calculus \lbm{} as presented by Curien and Herbelin \cite{curien-herbelin:2000} defines three types of terms \cite{van-bakel:2024}:
\begin{align*}
    c &\Coloneqq \langle t | e \rangle &(\textit{commands}) \\
    t &\Coloneqq x \alt (\lambda x. t) \alt (\mu \beta. c) &(\textit{terms}) \\
    e &\Coloneqq \alpha \alt (t \cdot e) \alt (\tilde{\mu}x. c) &(\textit{environments})
\end{align*}
where $x$ can be any symbol from an infinite list of term variables $a, b, c, \ldots, x, y, z \ldots$. \todo{What are $\alpha$ and $\beta$?} \lbm{} defines three kinds of statements, each typing a different syntactic category:
\begin{align*}
    \text{Statement} \Coloneqq{} &c: \Gamma \vdash \Delta &(\textit{commands}) \\
    |\  &\Gamma \vdash t: A \alt \Delta &(\textit{terms}) \\
    |\  &\Gamma \alt e: A \vdash \Delta &(\textit{environments})
\end{align*}
where $A$ represents a Curry type, while $\Gamma$ and $\Delta$ represent a set of variable type assignments. The type assignment rules are defined as follows:
\[
    (\textit{cut}): \frac{\Gamma \vdash t: A \alt \Delta \quad \Gamma \alt e: A \vdash \Delta}{\langle t|e \rangle: \Gamma \vdash \Delta}
\]

\begin{center}
    \begin{minipage}{.4\textwidth}
        \begingroup
        \addtolength{\jot}{1em}
        \begin{align*}
            (Ax_R)&: \frac{}{\Gamma, x: A \vdash x: A \alt \Delta} \\
            (\to R)&: \frac{\Gamma, x: A \vdash t: B \alt \Delta}{\Gamma \vdash (\lambda x. t): (A \to B) \alt \Delta} \\
            (\mu)&: \frac{c: \Gamma \vdash \alpha: A, \Delta}{\Gamma \vdash (\mu \alpha. c): A \alt \Delta}
        \end{align*}
        \endgroup
    \end{minipage}%
    \begin{minipage}{.4\textwidth}
        \begingroup
        \addtolength{\jot}{1em}
        \begin{align*}
            (Ax_L)&: \frac{}{\Gamma \alt \alpha: A \vdash \alpha: A, \Delta} \\
            (\to L)&: \frac{\Gamma \vdash t: A \alt \Delta \quad \Gamma \alt e: B \vdash \Delta}{\Gamma \alt (t \cdot e): (A \to B) \vdash \Delta} \\
            (\tilde{\mu})&: \frac{c: \Gamma, x: A \vdash \Delta}{\Gamma \alt (\tilde{\mu}x. c): A \vdash \Delta}
        \end{align*}
        \endgroup
    \end{minipage}
\end{center}

\section{User experience}
Students who took the Type Systems module in Autumn 2024 were invited to test the web application. They were asked to complete three tasks: the first task involves deriving a conclusion in the Curry type assignment system for the lambda calculus, the second task involves extending the lambda calculus and the Curry type assignment system, and the third task involves deriving a conclusion in the system \textsc{lk}.

\subsection{User testing tasks}
\subsubsection{Curry type assignment system for the lambda calculus}
In this task, the user is asked to derive the conclusion
\[
    \varnothing \vdash ((\lambda x. x)(\lambda y. y))
\]
in the Curry type assignment system using the web application. This particular conclusion is chosen because it is fairly simple and its derivation requires all three type assignment rules $(Ax)$, $(\to I)$, and $(\to E)$.

This task serves as a gentle introduction to the web application. The user only needs to focus on navigating the derivation building part of the web application and not other features, e.g. the syntax and inference rule editors. This task also serves as a quick refresher on building derivation trees, since the user testing was done around half a year after the Type Systems module had ended.

The goal of this task is to evaluate the intuitiveness of the derivation building part of the web application. In particular, the evaluation focuses on how confident the users can input conclusions, rule names, and add premises without guidance, as well as the usefulness of the error messages when the user provides an incorrect derivation.

\subsubsection{Lambda calculus with pairs}
In this task, the user is asked to extend the syntax of $\lambda$-terms and type assignment rules with pairs, as described in \Cref{evaluation:lambda-pairs}. Afterwards, the user is asked to derive the following conclusion:
\[
    x: (1 \times 2) \vdash \langle \textsf{left}(x), \textsf{right}(x) \rangle: (1 \times 2)
\]
This particular conclusion is chosen because it is fairly simple and its derivation uses all three newly added type assignment rules.

The goal of this task is to evaluate the intuitiveness of the syntax and inference rule editors. In particular, the evaluation focuses on how the users interact with the user interface to check the correctness of their definitions and the usefulness of the error messages and warnings.

\subsubsection{Sequent calculus system \textsc{lk}}
In this task, the user is asked to derive the following conclusion in the system \textsc{lk}:
\[
    ((x \lor y) \to z) \vdash (x \to z)
\]
This particular conclusion is chosen because its derivation requires the rule
\[
    (\to L): \frac{\Gamma \vdash A, \Delta \quad \Sigma, B \vdash \Pi}{\Gamma, \Sigma, (A \rightarrow B) \vdash \Delta, \Pi}
\]
which may appear quite complicated to users unfamiliar with the system \textsc{lk}, as they would need to pattern match numerous placeholders.

The goal of this task is to evaluate the usefulness of the error messages in the derivation tree and the rule viewers in guiding the users to build a correct derivation in an unfamiliar proof system.