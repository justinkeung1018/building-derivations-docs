\chapter{Rule checking}
\label{chapter:checking}
As the user builds the derivation tree, the application checks whether the inference rules are applied correctly and whether the derivation is complete and correct. Since the application only supports \textit{localised} inference rules, it suffices to check at every dividing line of the derivation tree, whether the user-inputted premises immediately above the line and the user-inputted conclusion immediately below the line are compatible with the inference rule specified by the user-inputted rule name. A derivation is complete and correct if and only if all inference rules in the derivation are compatible with the user input.

An inference rule is compatible with the user input if and only if there is a mapping of names (i.e. metavariables) to ASTs such that replacing all the names in the inference rule with the corresponding ASTs according to the mapping gives the user input. There can be many such mappings for a given inference rule and user input. Since the inference rules are localised, each mapping only applies to one application of an inference rule and need not apply to the rest of the derivation.

\Cref{checking:matching} describes the procedure for obtaining a mapping of names to ASTs given a user-inputted statement and the structure of the corresponding inference rule statement. \Cref{checking:verifying} describes how the procedure described in \Cref{checking:matching} is used to check whether all user-inputted premises and the user-inputted conclusion are compatible with the inference rule.

\section{Matching}
\label{checking:matching}
The aim of this step is to produce a mapping of names to ASTs. Matching is done individually to every inference rule statement.

\subsection{Inputs and outputs of the matching algorithm}
The matching algorithm takes in two mappings as arguments and modifies them in place. The two mappings are:
\begin{itemize}
    \item \lstinline{names}: a mapping where each entry maps a name (as a string) to an AST. A name \textit{must} be mapped to the AST according to \lstinline{names} if the inference rule is applied correctly.
    \item \lstinline{unmatchedPossibilities}: a mapping where each entry maps a name (as a string) that does not appear in \lstinline{names} to a set of ASTs. A name \textit{can} be mapped to any AST in the set according to \lstinline{unmatchedPossibilities} if the inference rule is applied correctly, yet it is not known which of the ASTs the name will ultimately end up getting mapped to at the time of matching.
\end{itemize}
The matching algorithm checks whether the mappings deduced from the user input and the structure of the inference rule statement are consistent with \lstinline{names} and \lstinline{unmatchedPossibilities}, and throws an error whenever it first finds an inconsistency.

\subsection{Procedure outline}
\label{matching:procedure}
\begin{enumerate}
    \item Parse the user-inputted statement into a list of ASTs.
    \item Check the list of ASTs has the same length as the list of \lstinline{Matchable} tokens in the inference rule statement.
    \item Pair up each AST with the corresponding \lstinline{Matchable} token and recursively match each pair.
    \item Repeat step 3 until no new names are added to \lstinline{names}.
\end{enumerate}
Step 3 is repeated because the mappings generated by matching the ASTs further down the list may imply mappings that could not be deduced in an earlier pass. Consider the conclusion of the action rule in natural deduction $\Gamma, A \vdash A$ and the user input $x, y \vdash y$. Suppose the ASTs and \lstinline{Matchable} tokens are matched from left to right starting with \lstinline{names} empty. Step 3 above can be broken down into the following smaller steps:
\begin{enumerate}
    \item Match $x, y$ with $\Gamma, A$. Since there are no existing mappings, $A$ can either be mapped to $x$ or $y$ and $\Gamma$ can either be mapped to the multiset containing $y$ or the multiset containing $x$.
    \item Match $\vdash$ with $\vdash$.
    \item Match $y$ with $A$. Clearly, $A$ must be mapped to $y$. This mapping is stored in \lstinline{names}.
\end{enumerate}
In the second iteration of step 3, when trying to match $x, y$ with $\Gamma, A$ again, the mapping of $A$ to $y$ implies the mapping of $\Gamma$ to the multiset containing $x$. This deduction could not be made in the first iteration.

The subsequent subsections explain step 3 in greater detail. From this point onwards, \lstinline{ast} and \lstinline{token} refer to the AST and the \lstinline{Matchable} token that are being matched, respectively.

\subsection{Matching a \texorpdfstring{\lstinline{TerminalAST}}{TerminalAST}}
Matching succeeds if and only if \lstinline{token} is a \lstinline{MatchableTerminal} containing the same string as \lstinline{ast}.

\subsection{Matching a \texorpdfstring{\lstinline{NonTerminalAST}}{NonTerminalAST}}
If \lstinline{token} is neither a \lstinline{Name} or a \lstinline{MatchableNonTerminal}, matching fails. Otherwise, if \lstinline{token} is a:
\begin{itemize}
    \item \lstinline{Name}: if the name is in \lstinline{names}, matching succeeds if and only if the mapped AST (i.e. \lstinline{names[name]}) is the same as \lstinline{ast}. Otherwise, create a new mapping from the name to \lstinline{ast}.
    \item \lstinline{MatchableNonTerminal}: if either of the following does not hold, matching fails:
    \begin{itemize}
        \item \lstinline{ast.index} is equal to \lstinline{token.index}. In other words, the rule number of \lstinline{ast} is the same as the rule number of \lstinline{token}.
        \item \lstinline{ast.children} has the same length as \lstinline{token.children}. In other words, there are as many children ASTs representing the structure of \lstinline{ast} as there are children \lstinline{Matchable} tokens representing the structure of \lstinline{token}.
    \end{itemize}
    If both of the above are true, pair up each child AST with the corresponding child \lstinline{Matchable} token and recursively match each pair, like in step 3 of \Cref{matching:procedure}.
\end{itemize}
\subsection{Matching a \texorpdfstring{\lstinline{MultisetAST}}{MultisetAST}}
If \lstinline{token} is not a \lstinline{MatchableMultiset}, matching fails. Otherwise, split up the \lstinline{elements} field of \lstinline{token} (which has type \lstinline{(Name | MultisetElement)[]}) into \lstinline{Name}s and \lstinline{MultisetElement}s.

For every \lstinline{Name} in \lstinline{token.elements}:
\begin{itemize}
    \item If the name is in \lstinline{names} (i.e. it is already mapped to an AST), check the mapped AST (i.e. \lstinline{names[name]}) has type \lstinline{MultisetAST}. Remove all elements in the mapped AST from \lstinline{ast.elements}. If any element in the mapped AST cannot be found in \lstinline{ast.elements}, throw an error.
    \item Otherwise, matching is postponed.

\end{itemize}

For every \lstinline{MultisetElement} in \lstinline{token.elements}, find all \textit{actual elements} (i.e. an element of \lstinline{ast.elements} with type \lstinline{AST[]}) that are compatible with the \lstinline{MultisetElement}. The procedure for finding compatible actual elements will be described in the next subsection.
\begin{itemize}
    \item If there are no matches, i.e. none of the actual elements are compatible with the \lstinline{MultisetElement}, throw an error.
    \item If there is exactly one match, i.e. exactly one actual element is compatible with the \lstinline{MultisetElement}, match the actual element with the \lstinline{MultisetElement}.
    \item If there are at least two matches, postpone the matching and update \lstinline{unmatchedPossibilities} as follows:
    \begin{enumerate}
        \item For every actual element that is compatible with the \lstinline{MultisetElement}, assume the \lstinline{MultisetElement} should be mapped to the actual element and generate a mapping where each entry maps a name in the \lstinline{MultisetElement} to an AST.
        \item For every name in the \lstinline{MultisetElement} but not in \lstinline{names} (i.e. it has not been mapped to an AST for certain), if it exists in \lstinline{unmatchedPossibilities}, update the corresponding entry as follows:
        \begin{center}
            \lstinline|unmatchedPossibilities[name] = { names1[name], names2[name], ... } $\cap$ unmatchedPossibilities[name]|
        \end{center}
        where \lstinline{names1}, \lstinline{names2}, etc. are the mappings generated from the previous step. Otherwise, if the name does not exist in \lstinline{unmatchedPossibilities}, create a new entry in \lstinline{unmatchedPossibilities} as follows:
        \begin{center}
            \lstinline|unmatchedPossibilities[name] = { names1[name], names2[name], ... }|
        \end{center}
    \end{enumerate}
\end{itemize}

\subsubsection{Finding actual elements compatible with a \texorpdfstring{\lstinline{MultisetElement}}{MultisetElement}}
Create an empty set of possibilities. For every actual element remaining in the user-inputted multiset (i.e. after all multiset names are matched and the elements in the mapped AST are removed from \lstinline{ast.elements}):
\begin{enumerate}
    \item Check the actual element (which has type \lstinline{AST[]}) has the same length as the \lstinline{children} field of the \lstinline{MultisetElement}. In other words, check there are as many children ASTs representing the structure of the actual element as there are children \lstinline{Matchable} tokens representing the structure of the \lstinline{MultisetElement}.
    \item Check the actual element is not already in the set of possibilities. Recall the aim of finding compatible actual elements is to determine whether the \lstinline{MultisetElement} can be matched with an actual element with certainty. If the \lstinline{MultisetElement} is compatible with multiple identical actual elements, there is no difference between matching the \lstinline{MultisetElement} with one of the duplicates and matching it with any of the other duplicates, since any modifications to \lstinline{names} will be identical.
    \item Make a shallow copy of \lstinline{names}. The copy is a new mapping from names (as strings) to ASTs where the ASTs share the same references as in \lstinline{names}. Assigning a new name or removing an existing name of the shallow copy will not affect \lstinline{names}, but modifying any of the ASTs will cause the same changes in \lstinline{names}. A shallow copy is acceptable since the matching algorithm only adds names to \lstinline{names} and never modifies the ASTs in place.
    \item Pair up each AST in the actual element with the corresponding \lstinline{Matchable} token of the \lstinline{MultisetElement}. Try to match each (AST, \lstinline{Matchable}) pair using the shallow copy of \lstinline{names}. A shallow copy of \lstinline{names} instead of \lstinline{names} is used because the matching may fail. The matching algorithm assumes the given AST \lstinline{must} be compatible with the given \lstinline{Matchable} token, so any error thrown indicates the user input is incorrect. This assumption is reasonable when matching at the top level, i.e. matching the user input with the structure of the inference rule statement, but less so when matching is used as a means to explore possibilities.
    \item If the matching succeeds, add the actual element to the set of possibilities.
\end{enumerate}

\section{Verifying}
\label{checking:verifying}
The aim of this step is to verify whether an inference rule is applied correctly by the user.

\subsection{Procedure outline}
Given a string representing the user-inputted conclusion, a list of strings representing the user-inputted premises, and the parsed inference rule, the verification algorithm is as follows:
\begin{enumerate}
    \item Check the user has given the same number of premises as defined in the inference rule.
    \item Repeat the following steps until no new names are added:
    \begin{enumerate}
        \item Match the user-inputted conclusion with the structure of the conclusion as defined by the inference rule.
        \item Match each user-inputted premise with the structure of the corresponding premise as defined by the inference rule.
    \end{enumerate}
    Here, the order of matching the abstract statements is arbitrary. Without analysing the structure of the inference rule, any matching order~ when given an arbitrary inference rule works equally well, since the matching algorithm is idempotent. For example, it is equally effective to match the premises before the conclusion or to match the premises in a random order. The matching steps are repeated for a similar reason as repeating step 3 in \Cref{matching:procedure}: matching a later inference rule statement may give more information for generating additional mappings when re-matching an earlier inference rule statement that cannot be generated on an earlier iteration.
    \item If \lstinline{unmatchedPossibilities} is empty, verification succeeds if and only if none of the matching steps throws any errors.
    \item Otherwise, recursively explore all possible assignments of names to ASTs. Verification succeeds if and only if there is at least one assignment that does not result in any error when parsing.
\end{enumerate}