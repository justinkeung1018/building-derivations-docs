\chapter{Terms}
\label{chapter:term}
Throughout this report, the word \textit{term} is used to refer to any instance or realisation of a syntax rule. For example, the term $((1 \to 2) \to 3)$ is an instance or realisation of the rule $A \Coloneqq 1 \alt 2 \alt 3 \alt (A \to A)$. The word is used without regards to the semantics of the syntax rules. For example, in the context of the $\lambda$-calculus, the aforementioned rule can be understood as the rule for a Curry type. A term can refer to any instance of a statement, a $\lambda$-term, and all other syntax rules defined by the user.

\section{Generating term parsers}
The aim of this step is to generate parsers for parsing terms, given as strings, into a list of abstract syntax trees (ASTs). One parser is generated for every syntax rule. Each parser outputs a list of ASTs. Each AST in the output list corresponds to a token in the parsed definition of the syntax rule. 

\subsection{Abstract syntax trees (ASTs)}
The ASTs are defined as follows:
\begin{lstlisting}
    class TerminalAST { constructor(readonly value: string) {} }

    class NonTerminalAST {
        constructor(readonly index: number, readonly children: AST[]) {} }

    class MultisetAST { constructor(readonly elements: AST[][]) {} }

    type AST = TerminalAST | NonTerminalAST | MultisetAST;
\end{lstlisting}
Notice that there are no ASTs corresponding to the \lstinline{Or} and \lstinline{Maybe} tokens. They are merely used to indicate how to generate parsers with \lstinline{parjs} in an idiomatic way and allow alternatives to be nested.

\subsection{Procedure}
\label{term:procedure}
A list of \textit{delayed parsers} is generated using the \lstinline{later} combinator. A \textit{delayed parser}\footnote{In \lstinline{parjs}, a delayed parser has type \lstinline{DelayedParjser<T>}.} is a parser that does not carry any logic and must be initialised before being used for parsing \cite{parjs}. A delayed parser can be chained and combined with other parsers like a normal parser. There are two main benefits of generating delayed parsers and later initialising them:
\begin{itemize}
    \item It is possible to generate parsers for recursive rules. When generating the parser for a rule containing references to itself, the parser must be incomplete at any point of reference since the reference is part of the definition. A similar logic applies to mutually recursive rules.
    \item There is no need to devise an order in which the parsers for each rule is generated (e.g. by topologically sorting the references, such that every rule only references ``earlier'' rules whose parsers would have been all initialised). In fact, such an order or topological sort does not exist when there is recursion, since the reference graph contains cycles.
\end{itemize}
A term parser is generated by iterating over the tokens in every alternative of of the rule and examining the type of the token:
\begin{enumerate}
    \item \lstinline{Terminal}: parse the string verbatim.
    \item \lstinline{NonTerminal}: use the (delayed) parser corresponding to the rule number of the \lstinline{NonTerminal}.
    \item \lstinline{Multiset}: either parse the string \lstinline{\varnothing} (corresponding to the empty set) or a comma-separated list of one or more elements. To generate the parser for a multiset element, a parser is generated for each token of the element definition. Each of these parsers are chained together using the \lstinline{then} combinator.
    \item \lstinline{Or}: parse one of the alternatives. A parser is generated for each of the alternatives. The parsers are then combined using the \lstinline{or} combinator.
    \item \lstinline{Maybe}: optionally parse one of the alternatives. A parser is generated for each of the alternatives. The parsers are then combined using the \lstinline{or} combinator, then piped with the \lstinline{maybe} combinator that returns an empty list on fallback. The \lstinline{maybe} combinator applies the source parser (i.e. the parser before it): it returns the result of the source parser if it succeeds, and the fallback result if the source parser fails softly \cite{parjs:maybe}.
\end{enumerate}