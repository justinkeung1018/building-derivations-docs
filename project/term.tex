\section{Concrete terms}
\label{section:term}
In this report, a \textit{concrete term} refers to an instance or realisation of a syntax rule in the derivation tree. A \textit{concrete term} can correspond to a Curry type, a $\lambda$-term, a multiset of propositional formulae, or any syntax rule defined by the user. For example, $((1 \to 2) \to 3)$ is a valid concrete term according to the rule $A \Coloneqq 1 \alt 2 \alt 3 \alt (A \to A)$, since it is a valid instance of the rule.

A \textit{concrete statement} is an instance or realisation of the syntax rule defining a statement.

A valid derivation tree consists of valid concrete statements and rule names. \projectname{} verifies whether each concrete statement conforms to the syntax rule defining a statement. This chapter describes the parsing algorithm that achieves this goal.

\subsection{Parsing concrete terms}
The aim of this step is to convert a term, given as a string, into a list of abstract syntax trees (ASTs). After parsing a syntax rule into \lstinline{Token}s, we generate a sub-parser for each \lstinline{Token} and combine the sub-parsers sequentially to form an overall parser. Each sub-parser outputs an AST, and the overall parser collects the ASTs from all sub-parsers into a list. The first AST is produced by the sub-parser corresponding to the first \lstinline{Token}, and so on.

\subsubsection{Abstract syntax trees (ASTs)}
The ASTs are defined as follows:
\begin{lstlisting}
    class TerminalAST { constructor(readonly value: string) {} }

    class NonTerminalAST {
        constructor(readonly index: number, readonly children: AST[]) {} }

    class MultisetAST { constructor(readonly elements: AST[][]) {} }

    type AST = TerminalAST | NonTerminalAST | MultisetAST;
\end{lstlisting}

\subsubsection{Procedure}
\label{term:procedure}
A list of \textit{delayed parsers} is generated using the \lstinline{later} combinator. A \textit{delayed parser}\footnote{In \lstinline{parjs}, a delayed parser has type \lstinline{DelayedParjser<T>}.} is a parser that does not carry any logic and must be initialised before being used for parsing \cite{parjs}. A delayed parser can be chained and combined with other parsers like a normal parser. There are two main benefits of generating delayed parsers and later initialising them:
\begin{itemize}
    \item It is possible to generate parsers for recursive rules. When generating the parser for a rule containing references to itself, the parser must be incomplete at any point of reference since the reference is part of the definition. A similar logic applies to mutually recursive rules.
    \item There is no need to devise an order in which the parsers for each rule is generated (e.g. by topologically sorting the references, such that every rule only references ``earlier'' rules whose parsers would have been all initialised). In fact, such an order or topological sort does not exist when there is recursion, since the reference graph contains cycles.
\end{itemize}
A term parser is generated by iterating over the tokens in every alternative of of the rule and examining the type of the token:
\begin{enumerate}
    \item \lstinline{Terminal}: parse the string verbatim.
    \item \lstinline{NonTerminal}: use the (delayed) parser corresponding to the rule number of the \lstinline{NonTerminal}.
    \item \lstinline{Multiset}: either parse the string \lstinline{\varnothing} (corresponding to the empty set) or a comma-separated list of one or more elements. To generate the parser for a multiset element, a parser is generated for each token of the element definition. Each of these parsers are chained together using the \lstinline{then} combinator.
\end{enumerate}