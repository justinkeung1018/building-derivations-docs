\chapter{User-inputted terms}
\label{chapter:term}
In this report, a \textit{user-inputted term} refers to an instance or realisation of a syntax rule in the derivation tree. A \textit{user-inputted term} can correspond to a Curry type, a $\lambda$-term, a multiset of propositional formulas, or any syntax rule defined by the user. For example, $((1 \to 2) \to 3)$ is a valid user-inputted term corresponding to the rule $A \Coloneqq 1 \alt 2 \alt 3 \alt (A \to A)$, since it is a valid instance of the rule.

A \textit{user-inputted statement} is a \textit{user-inputted term} corresponding to the syntax rule defining a statement.

A valid derivation tree consists of valid user-inputted statements and rule names. The application must be able to verify whether each user-inputted statement conforms to the syntax rule defining a statement. This chapter describes the parsing algorithm that achieves this goal.

\section{Generating term parsers}
The aim of this step is to generate parsers for parsing terms, given as strings, into a list of abstract syntax trees (ASTs). One parser is generated for every syntax rule. Each parser outputs a list of ASTs. Each AST in the output list corresponds to a token in the parsed definition of the syntax rule.

\subsection{Abstract syntax trees (ASTs)}
The ASTs are defined as follows:
\begin{lstlisting}
    class TerminalAST { constructor(readonly value: string) {} }

    class NonTerminalAST {
        constructor(readonly index: number, readonly children: AST[]) {} }

    class MultisetAST { constructor(readonly elements: AST[][]) {} }

    type AST = TerminalAST | NonTerminalAST | MultisetAST;
\end{lstlisting}

\subsection{Procedure}
\label{term:procedure}
A list of \textit{delayed parsers} is generated using the \lstinline{later} combinator. A \textit{delayed parser}\footnote{In \lstinline{parjs}, a delayed parser has type \lstinline{DelayedParjser<T>}.} is a parser that does not carry any logic and must be initialised before being used for parsing \cite{parjs}. A delayed parser can be chained and combined with other parsers like a normal parser. There are two main benefits of generating delayed parsers and later initialising them:
\begin{itemize}
    \item It is possible to generate parsers for recursive rules. When generating the parser for a rule containing references to itself, the parser must be incomplete at any point of reference since the reference is part of the definition. A similar logic applies to mutually recursive rules.
    \item There is no need to devise an order in which the parsers for each rule is generated (e.g. by topologically sorting the references, such that every rule only references ``earlier'' rules whose parsers would have been all initialised). In fact, such an order or topological sort does not exist when there is recursion, since the reference graph contains cycles.
\end{itemize}
A term parser is generated by iterating over the tokens in every alternative of of the rule and examining the type of the token:
\begin{enumerate}
    \item \lstinline{Terminal}: parse the string verbatim.
    \item \lstinline{NonTerminal}: use the (delayed) parser corresponding to the rule number of the \lstinline{NonTerminal}.
    \item \lstinline{Multiset}: either parse the string \lstinline{\varnothing} (corresponding to the empty set) or a comma-separated list of one or more elements. To generate the parser for a multiset element, a parser is generated for each token of the element definition. Each of these parsers are chained together using the \lstinline{then} combinator.
\end{enumerate}